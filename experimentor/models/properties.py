""" Every model in Experimentor has a set of properties that define their state. A camera has, for example, an exposure
time, a DAQ card has a delay between data points, and an Experiment holds global parameters, such as the number of
repetitions a measurement should take.

In many situations, the parameters are stored as a dictionary, mainly because they are easy to retrieve from a file on
the hard drive and to access from within the class. We want to keep that same approach, but adding extra features.

Features of Properties
----------------------
Each parameter stored on a property will have three values: new_value, value, old_value, which represent the value which
will be set, the value that is currently set and the value that was there before. In this way it is possible to just
update on the device those values that need updating, it is also possible to revert back to the previously known value.

Each value will also be marked with a flag to_update in case the value was changed, but not yet transmitted to the
device. This allows us to collect all the values we need, for example looping through a user interface, reading a config
file, and applying only those needed whenever desired.

The Properties have also another smart feature, achieved through linking. Linking means building a relationship between
the parameters stored within the class and the methods that need to be executed in order to get or set those values. In
the linking procedure, we can set only getter methods for read-only properties, or both methods. A general apply
function then allows to use the known methods to set the values that need to be updated to the device.

Future Roadmap
--------------
We can consider forcing methods to always act on properties defined as new/known/old in order to use that information as
a form of cache and validation strategy.
"""
import warnings
from typing import List

from experimentor.lib.log import get_logger
from experimentor.lib.recursive_attributes import rgetattr
from experimentor.models.exceptions import LinkException, PropertyException


class Properties:
    """ Class to store the properties of models. It keeps track of changes in order to monitor whether a specific value
    needs to be updated. It also allows to keep track of what method should be triggered for each update.
    """

    def __init__(self, parent: object, **kwargs):
        self._parent = parent
        self._properties = dict()
        self._links = dict()
        self.logger = get_logger()
        if kwargs:
            for key, value in kwargs.items():
                self.__setitem__(key, value)

    def __setitem__(self, key, value):
        if key not in self._properties:
            self._properties.update({
                key:
                    {
                        'new_value': value,
                        'value': None,
                        'old_value': None,
                        'to_update': True
                    }
                })
        else:
            self._properties[key].update({
                'new_value': value,
                'to_update': True,
            })

    def __getitem__(self, item):
        if isinstance(item, int):
            key = list(self._properties.keys())[item]
            return {key: self._properties[key]['value']}
        return self._properties[item]['value']

    def all(self) -> dict:
        """ Returns a dictionary with all the known values. """
        p = dict()
        for key, value in self._properties.items():
            p.update({
                key: value['value'],
            })
        return p

    def update(self, values: dict):
        """Updates the values in the same way the update method of a dictionary works. It, however, stores the values
        as a new value, it does not alter the values stored. For updating the proper values use :func:`self.upgrade`
        """
        for key, value in values.items():
            self.__setitem__(key, value)

    def upgrade(self, values: dict):
        """This method actually overwrites the values stored in the properties. This method should be used only when the
        real values generated by a device are known. It will change the new values to None, it will set the value to
        value, and it will set the ``to_update`` flag to false.

        Parameters
        ----------
        values: dict
            Dictionary in the form {property: new_value}
        """
        for key, value in values.items():
            if key not in self._properties:
                raise PropertyException(f'Trying to upgrade {key} but is not a listed property')
            self._properties[key].update({
                'new_value': None,
                'value': value,
                'to_update': False,
            })

    def fetch(self, prop: str):
        """ Fetches the desired property from the device, provided that a link is available. """
        if prop in self._links:
            getter_name = self._links[prop][0]
            getter = rgetattr(self._parent, getter_name)
            if callable(getter):
                value = getter()
            else:
                value = getter
            self.logger.debug(f'Fetched {prop} -> {value}')
            return value
        else:
            self.logger.error(f'{prop} is not a valid property')
            raise KeyError(f'{prop} is not a valid property')

    def fetch_all(self):
        """ Fetches all the properties for which a link has been established and updates the value. This method does
        not alter the to_update flag, new_value, nor old_value.
        """
        self.logger.info(f'Fetching all properties of {self._parent}')
        for key in self._links:
            value = self.fetch(key)
            self._properties[key]['value'] = value

    def apply(self):
        """ Applies all changes marked as 'to_update', using the links to methods generated with :meth:~link
        """
        values_to_update = self.to_update()
        for key, values in values_to_update.items():
            if key in self._links:
                setter_name = self._links[key][1]
                if setter_name:
                    new_value = values['new_value']
                    setter = rgetattr(self._parent, setter_name)
                    value = setter(new_value)
                    if value is None:
                        value = self.fetch(key)
                    self.upgrade({key: value})
                else:
                    self.logger.info(f'Trying to change the value of {key}, but it is read-only')
            else:
                warnings.warn(f'{key} is a property marked to update but it is not linked to a setter method')

    def get_property(self, prop: str) -> dict:
        """Get the information of a given property, including the new value, value, old value and if it is marked as to
        be updated.
        """
        return self._properties[prop]

    def to_update(self) -> dict:
        """Returns a dictionary containing all the properties marked to be updated. """
        props = {}
        for key, values in self._properties.items():
            if values['to_update']:
                props[key] = values
        return props

    def link(self, linking: dict) -> None:
        """Link properties to methods for update and retrieve them.

        :param linking: Dictionary in where information is stored as parameter=>[getter, setter], for example:
            linking = {'exposure_time': ['get_exposure', 'set_exposure']}
            In this case, ``exposure_time`` is the property stored, while ``get_exposure`` is the method that will be
            called for getting the latest value, and set_exposure will be called to set the value. In case set_exposure
            returns something different from None, no extra call to get_exposure will be made.
        """
        for key, value in linking.items():
            if key in self._links and self._links[key] is not None:
                raise LinkException(f'That property is already linked to {self._links[key]}. Please, unlink first')
            if not isinstance(value, list):
                self._links[key] = [value, None]
            else:
                if len(value) == 1:
                    self._links[key] = value.append(None)
                elif len(value) == 2:
                    self._links[key] = value
                else:
                    raise PropertyException(f'Properties only accept setters and getter, trying to link {key} with {len(value)} methods')

    def unlink(self, unlink_list: List[str]) -> None:
        """ Unlinks the properties and the methods. This is just to prevent overwriting linkings under the hood and
        forcing the user to actively unlink before linking again.

        :param unlink_list: List containing the names of the properties to be unlinked.
        """
        for link in unlink_list:
            if link in self._links:
                self._links[link] = None
            else:
                warnings.warn('Unlinking a property which was not previously linked.')

    @classmethod
    def from_dict(cls, parent, data: dict):
        """Create a Properties object from a dictionary, including the linking information for methods. The data has
        to be passed in the following form: {property: [value, getter, setter]}, where `getter` and `setter` are the
        methods used by :meth:~link.
        """
        parameters = dict()
        links = dict()
        for key, values in data.items():
            parameters.update({
                key: values[0]
            })
            links.update({
                key: values[1:]
            })
        props = cls(parent, **parameters)
        props.link(links)
        return props

    def __repr__(self):
        return repr(self.all())

